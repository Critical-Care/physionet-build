# Generated by Django 2.1.7 on 2019-07-27 03:36

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import project.models
import project.validators
import user.validators
from itertools import chain
from project.models import Author, Metadata, Publication, Reference, Topic
from django.db import models
from django.contrib.contenttypes.models import ContentType


project_map = {}


def migrate_projects(apps, schema_editor):
    # Gets all projects currently in the database
    data = chain(
        apps.get_model("project", "PublishedProject").objects.all().order_by('pk'),
        apps.get_model("project", "ArchivedProject").objects.all(),
        apps.get_model("project", "ActiveProject").objects.all()
    )

    # Moves data to new table
    for d in data:
        project = Metadata()
        for field in project._meta.fields:
            # Verifies if field exists in old model
            old_fields = [f.name for f in d._meta.fields]
            if field.name not in old_fields: continue

            # Skip id field to avoid overwriting records
            if field.name == 'id': continue

            # Gets field value
            value = field.value_from_object(d)

            # ForeignKeys need to be assigned diferently
            if field.get_internal_type() == "ForeignKey" and value is not None:
                model = field.related_model
                setattr(project, field.name, model.objects.get(pk=value))
            else:
                setattr(project, field.name, value)
        
        # Save project in new model
        project.save()

        # Update project map dict
        # This dict will be used to update all models that referenced projects
        content_type = ContentType.objects.get_for_model(d.__class__).id
        if content_type not in project_map:
            project_map[content_type] = {}
        project_map[content_type][d.pk] = project.pk

        # All remote relations need to be updated
        for rel in d._meta.get_fields():
            # Only capture relations
            model = rel.related_model
            if model is None: continue

            # Skips relations attached to this object
            # These were updated above
            # We only need to update remote fields
            if 'ForeignKey' in str(rel.__class__): continue

            # Get name and instances for relation
            name = rel.remote_field.name
            instances = model.objects.filter(**{name: d.pk})

            for i in instances:
                project.__class__ = d.__class__
                try:
                    # Replace project attribute
                    setattr(i, name, project)
                    i.save()
                except TypeError:
                    # Deals with Many-to-Many relations
                    # Replace project attribute
                    getattr(i, name).remove(d)
                    getattr(i, name).add(project)
                    i.save()


def migrate_authors(apps, schema_editor):
    # Gets all authors currently in the database
    data = apps.get_model("project", "Author").objects.all()

    # Migrate GenericForeignKey (object_id) to Project
    for d in data:
        # Object FK
        field = d._meta.get_field('object_id')
        value = field.value_from_object(d)

        # Model (content_type)
        content_type = d._meta.get_field('content_type').value_from_object(d)

        # Assign project_id
        d.project_id = project_map[content_type][value]
        d.save()
    
    # Gets all publishedauthors currently in the database
    data = apps.get_model("project", "PublishedAuthor").objects.all()

    # Moves data to new table
    for d in data:
        author = Author()
        for field in author._meta.fields:
            # Verifies if field exists in old model
            old_fields = [f.name for f in d._meta.fields]
            if field.name not in old_fields: continue

            # Skip id field to avoid overwriting records
            if field.name == 'id': continue
            
            # Gets field value
            value = field.value_from_object(d)

            # ForeignKeys need to be assigned diferently
            if field.get_internal_type() == "ForeignKey":
                model = field.related_model
                setattr(author, field.name, model.objects.get(pk=value))
            else:
                setattr(author, field.name, value)

        # Save author in new model
        author.save()
        
        # Assign Author id to child PublishedAuthor
        d.author_ptr = author.id
        d.save()


def migrate_published(apps, schema_editor):
    # Gets all publications currently in the database
    data = chain(
        apps.get_model("project", "Publication").objects.all(),
        apps.get_model("project", "Reference").objects.all()
    )

    # Migrate GenericForeignKey (object_id) to Project
    for d in data:
        # Object FK
        field = d._meta.get_field('object_id')
        value = field.value_from_object(d)

        # Model (content_type)
        content_type = d._meta.get_field('content_type').value_from_object(d)

        # Assign project_id
        d.project_id = project_map[content_type][value]
        d.save()

    # Gets all publishedpublications currently in the database
    objects = [
        (Publication, apps.get_model("project", "PublishedPublication").objects.all()),
        (Reference, apps.get_model("project", "PublishedReference").objects.all())
    ]

    for (data_type, data) in objects:
        # Moves data to new table
        for d in data:
            instance = data_type()
            for field in instance._meta.fields:
                # Verifies if field exists in old model
                old_fields = [f.name for f in d._meta.fields]
                if field.name not in old_fields: continue

                # Skip id field to avoid overwriting records
                if field.name == 'id': continue

                # Gets field value
                value = field.value_from_object(d)

                # ForeignKeys need to be assigned diferently
                if field.get_internal_type() == "ForeignKey":
                    model = field.related_model
                    setattr(instance, field.name, model.objects.get(pk=value))
                else:
                    setattr(instance, field.name, value)

            # Save instance in new model
            instance.save()


def migrate_fk(apps, schema_editor):
    # Gets all authors currently in the database
    data = chain(
        apps.get_model("project", "SectionContent").objects.all(),
        apps.get_model("project", "Topic").objects.all(),
        apps.get_model("project", "EditLog").objects.all(),
        apps.get_model("project", "CopyeditLog").objects.all()
    )

    # Migrate GenericForeignKey (object_id) to Project
    for d in data:
        # Object FK
        field = d._meta.get_field('object_id')
        value = field.value_from_object(d)

        # Model (content_type)
        content_type = d._meta.get_field('content_type').value_from_object(d)

        # Assign project_id
        d.project_id = project_map[content_type][value]
        d.save()


def migrate_topics(apps, schema_editor):
    # Gets all publishedtopics currently in the database
    data = apps.get_model("project", "PublishedTopic").objects.all()
    data = data.values_list('description', 'projects__id')

    for description, p in data:
        project = Metadata.objects.get(pk=p)
        Topic.objects.create(project=project, description=description)


class Migration(migrations.Migration):

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ('user', '0015_auto_20190709_1005'),
        ('notification', '0005_auto_20190502_1444'),
        ('project', '0026_auto_20190716_1437'),
    ]

    operations = [
        #******************#
        # Migrate Metadata #
        #******************#

        # Create Metadata model
        migrations.CreateModel(
            name='Metadata',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('submission_datetime', models.DateTimeField(blank=True, null=True)),
                ('author_comments', models.CharField(blank=True, default='', max_length=1000)),
                ('editor_assignment_datetime', models.DateTimeField(blank=True, null=True)),
                ('revision_request_datetime', models.DateTimeField(blank=True, null=True)),
                ('resubmission_datetime', models.DateTimeField(blank=True, null=True)),
                ('editor_accept_datetime', models.DateTimeField(blank=True, null=True)),
                ('copyedit_completion_datetime', models.DateTimeField(blank=True, null=True)),
                ('author_approval_datetime', models.DateTimeField(blank=True, null=True)),
                ('title', models.CharField(max_length=200, validators=[user.validators.validate_alphaplus])),
                ('abstract', project.models.SafeHTMLField(blank=True, max_length=10000)),
                ('release_notes', project.models.SafeHTMLField(blank=True)),
                ('short_description', models.CharField(blank=True, max_length=250)),
                ('access_policy', models.SmallIntegerField(choices=[(0, 'Open'), (1, 'Restricted'), (2, 'Credentialed')], default=0)),
                ('project_home_page', models.URLField(blank=True, default='')),
                ('creation_datetime', models.DateTimeField(auto_now_add=True)),
                ('version', models.CharField(blank=True, default='', max_length=15, validators=[project.validators.validate_version])),
                ('version_order', models.PositiveSmallIntegerField(default=0)),
                ('submission_status', models.PositiveSmallIntegerField(default=0)),
                ('modified_datetime', models.DateTimeField(auto_now=True)),
                ('publish_datetime', models.DateTimeField(null=True)),
                ('archive_datetime', models.DateTimeField(null=True)),
                ('archive_reason', models.PositiveSmallIntegerField(null=True)),
                ('is_new_version', models.BooleanField(default=False)),
                ('slug', models.SlugField(max_length=20)),
                ('main_storage_size', models.BigIntegerField(default=0)),
                ('compressed_storage_size', models.BigIntegerField(default=0)),
                ('deprecated_files', models.BooleanField(default=False)),
                ('doi', models.CharField(default='', max_length=50)),
                ('is_legacy', models.BooleanField(default=False)),
                ('full_description', project.models.SafeHTMLField(default='')),
                ('is_latest_version', models.BooleanField(default=True)),
                ('has_other_versions', models.BooleanField(default=False)),
                ('featured', models.BooleanField(default=False)),
                ('has_wfdb', models.BooleanField(default=False)),
                ('approved_users', models.ManyToManyField(db_index=True, to=settings.AUTH_USER_MODEL)),
                ('core_project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='projects', to='project.CoreProject')),
                ('editor', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='editing_metadatas', to=settings.AUTH_USER_MODEL)),
                ('license', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, to='project.License')),
                ('programming_languages', models.ManyToManyField(blank=True, related_name='metadatas', to='project.ProgrammingLanguage')),
                ('resource_type', models.ForeignKey(db_column='resource_type', on_delete=django.db.models.deletion.PROTECT, related_name='metadatas', to='project.ProjectType')),
            ],
        ),

        # Modify FKs to use the Metadata model
        migrations.AlterField(
            model_name='authorinvitation',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='authorinvitations', to='project.Metadata'),
        ),
        migrations.AlterField(
            model_name='contact',
            name='project',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='contact', to='project.Metadata'),
        ),
        migrations.AlterField(
            model_name='dataaccess',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='dataaccesss', to='project.Metadata'),
        ),
        migrations.AlterField(
            model_name='duasignature',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='project.Metadata'),
        ),
        migrations.AlterField(
            model_name='gcp',
            name='project',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='gcp', to='project.Metadata'),
        ),
        migrations.AlterField(
            model_name='storagerequest',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='storagerequests', to='project.Metadata'),
        ),

        # Create parent projects mapping
        migrations.AddField(
            model_name='metadata',
            name='parent_projects',
            field=models.ManyToManyField(blank=True, related_name='derived_metadatas', to='project.Metadata'),
        ),

        # Move data from ActiveProject, PublishedProject and ArchivedProject
        migrations.RunPython(migrate_projects),

        # Enforce constraints
        migrations.AlterUniqueTogether(
            name='metadata',
            unique_together={('core_project', 'version')},
        ),

        # Delete old models
        migrations.DeleteModel(
            name='ActiveProject',
        ),
        migrations.DeleteModel(
            name='ArchivedProject',
        ),

        migrations.DeleteModel(
            name='PublishedProject',
        ),

        # Add proxy models
        migrations.CreateModel(
            name='PublishedProject',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
            },
            bases=('project.metadata',),
        ),
        migrations.CreateModel(
            name='ActiveProject',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
            },
            bases=('project.metadata', project.models.UnpublishedProject),
        ),
        migrations.CreateModel(
            name='ArchivedProject',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
            },
            bases=('project.metadata', project.models.UnpublishedProject),
        ),


        #*************************#
        # Migrate PublishedAuthor #
        #*************************#

        # PublishedAuthor is now child of Author instead of independent entity
        # and this migration creates parent Author objects from existing PublishedAuthors

        # Set GenericForeignKey as nullable
        # This is necessary because a single Metadata entity replaced all the old Project entities
        # and we do not assign these to the new parent objects when migrating
        migrations.AlterField(
            model_name='author',
            name='object_id',
            field=models.PositiveIntegerField(null=True)
        ),
        migrations.AlterField(
            model_name='author',
            name='content_type',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='contenttypes.ContentType'),
        ),

        # Add new ForeignKey to Metadata model
        # This is nullable here because assigning defaults might lead to mistakes
        # We enforce non-nullable constraint after migrating the data
        migrations.AddField(
            model_name='author',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='authors', to='project.Metadata')
        ),
        
        # Add parent pointer to PublishedAuthor
        # Initially this a PositiveSmallIntegerField
        # this is nullable here because assigning defaults might induce to mistakes
        # we later enforce the constraints to assure that this is properly populated
        migrations.AddField(
            model_name='publishedauthor',
            name='author_ptr',
            field=models.PositiveSmallIntegerField(null=True)
        ),

        # Remove unique constraint (This was moved to the parent Author object)
        # This relied on the GenericForeignKey which will not be used anymore
        # and would raise errors when creating the new parent Author objects
        migrations.AlterUniqueTogether(
            name='publishedauthor',
            unique_together=set(),
        ),

        # Alter corresponding_email type
        migrations.AlterField(
            model_name='author',
            name='corresponding_email',
            field=models.EmailField(max_length=254, null=True),
        ),

        # Migrate Author data
        # This creates a parent Author for each PublishedAuthor
        # and also replicates the PublishedAuthors to the updated model
        migrations.RunPython(migrate_authors),

        # Alter project FK and enforce constraints
        migrations.AlterField(
            model_name='author',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='authors', to='project.Metadata')
        ),
        migrations.AlterUniqueTogether(
            name='author',
            unique_together={('user', 'project'), ('display_order', 'project')},
        ),

        # Replace old primary key and alter parent pointer to enforce constraints
        migrations.RemoveField(
            model_name='publishedauthor',
            name='id'
        ),
        migrations.AlterField(
            model_name='publishedauthor',
            name='author_ptr',
            field=models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='project.Author'),
        ),

        # Update Author fields
        migrations.RemoveField(
            model_name='author',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='author',
            name='object_id',
        ),

        # Remove fields that are part of the parent model
        migrations.RemoveField(
            model_name='publishedauthor',
            name='corresponding_email',
        ),
        migrations.RemoveField(
            model_name='publishedauthor',
            name='approval_datetime',
        ),
        migrations.RemoveField(
            model_name='publishedauthor',
            name='display_order',
        ),
        migrations.RemoveField(
            model_name='publishedauthor',
            name='is_corresponding',
        ),
        migrations.RemoveField(
            model_name='publishedauthor',
            name='is_submitting',
        ),
        migrations.RemoveField(
            model_name='publishedauthor',
            name='project',
        ),
        migrations.RemoveField(
            model_name='publishedauthor',
            name='user',
        ),


        #*******************************#
        # Migrate Reference/Publication #
        #*******************************#

        # Add non-generic FK
        migrations.AddField(
            model_name='reference',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='references', to='project.Metadata')
        ),
        migrations.AddField(
            model_name='publication',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='publications', to='project.Metadata')
        ),

        # Set GenericForeignKey as nullable
        # This is necessary because a single Metadata entity replaced all the old Project entities
        # and we do not assign these to the new parent objects when migrating
        migrations.AlterField(
            model_name='reference',
            name='object_id',
            field=models.PositiveIntegerField(null=True)
        ),
        migrations.AlterField(
            model_name='reference',
            name='content_type',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='contenttypes.ContentType'),
        ),
        migrations.AlterField(
            model_name='publication',
            name='object_id',
            field=models.PositiveIntegerField(null=True)
        ),
        migrations.AlterField(
            model_name='publication',
            name='content_type',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='contenttypes.ContentType'),
        ),

        # Remove unique constraint
        # This relied on the GenericForeignKey which will not be used anymore
        migrations.AlterUniqueTogether(
            name='reference',
            unique_together=set(),
        ),

        # Replace GenericForeignKey
        migrations.RunPython(migrate_published),

        # Remove GenericFK
        migrations.RemoveField(
            model_name='reference',
            name='object_id',
        ),
        migrations.RemoveField(
            model_name='reference',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='publication',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='publication',
            name='object_id',
        ),

        # Enforce constraints
        migrations.AlterUniqueTogether(
            name='reference',
            unique_together={('description', 'project')},
        ),
        migrations.AlterField(
            model_name='reference',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='references', to='project.Metadata')
        ),
        migrations.AlterField(
            model_name='publication',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='publications', to='project.Metadata')
        ),

        # Remove discontinued model
        migrations.DeleteModel(
            name='PublishedReference',
        ),
        migrations.DeleteModel(
            name='PublishedPublication',
        ),


        #****************************#
        # Remove remaining GenericFK #
        #****************************#

        # Add non-generic FK
        migrations.AddField(
            model_name='sectioncontent',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='project_content', to='project.Metadata')
        ),
        migrations.AddField(
            model_name='topic',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='topics', to='project.Metadata')
        ),
        migrations.AddField(
            model_name='editlog',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='edit_logs', to='project.Metadata')
        ),
        migrations.AddField(
            model_name='copyeditlog',
            name='project',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='copyedit_logs', to='project.Metadata')
        ),

        # Update constraints
        migrations.AlterUniqueTogether(
            name='sectioncontent',
            unique_together=set(),
        ),
        migrations.AlterUniqueTogether(
            name='topic',
            unique_together=set(),
        ),

        # Replace GenericForeignKey
        migrations.RunPython(migrate_fk),

        # Enforce constraints
        migrations.AlterField(
            model_name='sectioncontent',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='project_content', to='project.Metadata')
        ),
        migrations.AlterField(
            model_name='topic',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='topics', to='project.Metadata')
        ),
        migrations.AlterField(
            model_name='editlog',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='edit_logs', to='project.Metadata')
        ),
        migrations.AlterField(
            model_name='copyeditlog',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='copyedit_logs', to='project.Metadata')
        ),

        # Remove GenericFK
        migrations.RemoveField(
            model_name='sectioncontent',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='sectioncontent',
            name='object_id',
        ),
        migrations.RemoveField(
            model_name='topic',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='topic',
            name='object_id',
        ),
        migrations.RemoveField(
            model_name='editlog',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='editlog',
            name='object_id',
        ),
        migrations.RemoveField(
            model_name='copyeditlog',
            name='content_type',
        ),
        migrations.RemoveField(
            model_name='copyeditlog',
            name='object_id',
        ),

        # Update constraints
        migrations.AlterUniqueTogether(
            name='sectioncontent',
            unique_together={('project', 'project_section')},
        ),
        migrations.AlterUniqueTogether(
            name='topic',
            unique_together={('description', 'project')},
        ),


        #*************************#
        # Migrate PublishedTopics #
        #*************************#

        migrations.RunPython(migrate_topics),
        migrations.DeleteModel(
            name='PublishedTopic',
        ),
        migrations.CreateModel(
            name='PublishedTopic',
            fields=[
            ],
            options={
                'proxy': True,
                'indexes': [],
            },
            bases=('project.topic',),
        ),


        #******************************#
        # Migrate PublishedAffiliation #
        #******************************#

        migrations.DeleteModel(
            name='PublishedAffiliation',
        ),
    ]
